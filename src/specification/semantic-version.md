## 语义版本控制(Semantic Versioning 2.0)

#### 基本介绍

语义化版本由三部分组成：`major.minor.patch`。

* `major`：主版本号，当你的包拥有不兼容的API变更时需要增加该版本号的值。
* `minor`：次版本号，当你以向后兼容的方式为你的包增加功能时需要增加该版本号。
* `patch`：补丁版本号，当你的包拥有向后兼容的bug修复时需要增加该版本号。

实际上你可以在 `major.minor.patch` 格式上进行扩展，添加预发布版本(`pre-release version`)和版本的构建元数据(`build metadata`)。

语义版本控制的好处是，如果一个包的版本号变更完全依照语义版本控制的规定，那么使用者将很容易的从版本号的变更中得知此包底层代码的变更，这对于包的使用者来说意义重大。同时一个依照语义版本控制的包也将会被包的发现者认为是更加“靠谱的”。

#### 语义版本空的规范

请注意下文中出现的关键词，如：**必须**、**不能/不得**、**需要**、**可以** 等。实际上这些关键词也是有规范来定义的，具体查看：[https://tools.ietf.org/html/rfc2119](https://tools.ietf.org/html/rfc2119)

* 1、使用语义版本的项目**必须**要有对该项目公共API清晰且全面的介绍。
* 2、普通的版本号格式**必须**符合 `major.minor.patch` 的格式，且 `major`、`minor` 和 `patch` 都是非负整数(即正整数或0)，并且**不能**包含前导0。每个版本号元素都**必须**以数字递增的方式增加，例如：`1.9.0` -> `1.10.0` -> `1.11.0`
* 3、一个包发布了某个版本之后，该版本的内容将**不得**修改。任何修改**必须**作为新版本再次发布。
* 4、如果你要发布一个初始开发的包(即正在开发中或未经测试的包)，那么该包的主版本号**需要**为 `0`，例如 `0.1.2`。这意味着该包的API还不稳定，随时可能发生变化。
* 5、`1.0` 版本包意味着该包定义了稳定的公共的API，该包版本号后续的变更取决于该包的更改方式和API的变更。
* 6、如果你只是引入了向后兼容的bug修复，则**必须**增加补丁版本号(`patch`)。
* 7、如果新的且向后兼容的功能被添加到公共API，则**必须**增加次版本号(`minor`)，同样的如果把现有API标记为被反对的，也**必须**增加次版本号(`minor`)。如果你的包添加一些实质性的新功能或者改善，你也**可以**增加次版本号(`minor`)。最后要注意的是，如果次版本号(`minor`)增加了，那么**必须**要将补丁版本号(`patch`)重置为0。
* 8、如果有新的且不向后兼容的功能被添加到了API，那么主版本号(`major`)**必须**增加。注意，如果主版本号(`major`)增加了，那么**必须**要将次版本号(`minor`)以及补丁版本号(`patch`)全部重置为0。
* 9、**可以**在补丁版本号(`patch`)之后使用连字符(`-`)和一些列的点分隔符(`.`)来标识预发布版本号(`pre-release version`)。标识符**必须**只能由字母、数字或者连字符(`-`)组成，且不能为空，数字类型的标识符**不能**有前导0。预发布版本号(`pre-release version`)的优先级低于其关联的普通版本。一个预发布版本号(`pre-release version`)代表着该版本是不稳定的，并且该版本可能不满足其关联的普通版本的兼容性要求。一些预发布版本号的例子：`1.0.0-alpha`、`1.0.0-alpha.1`、`1.0.0-0.3.7`、`1.0.0-x.7.z.92`。
* 10、**可以**在补丁版本号(`patch`)或预发布版本号(`pre-release version`)之后使用加号(`+`)以及一系列的点分隔符(`.`)为该版本添加构建元数据(`build metadata`)，构建元数据的标识符**必须**只能由字母、数字、连字符组成且不能为空。构建元数据不参与版本号优先级的比较，这意味着只有构建元数据不同的两个版本具有相同的优先级。例如这几个版本具有相同的优先级：`1.0.0-alpha+001`、`1.0.0+20130313144700`、`1.0.0-beta+exp.sha.5114f85`。
* 11、优先级定义了在版本号排序的过程中版本号是如何互相比较的，**必须**通过将版本号按顺序分为 `major`、`minor`、`patch` 和 `pre-release` 并一次对比他们的标识符来计算优先级。当从左到右比较这些标识符中的每一个时，优先级由第一个差异确定，规则如下：
  * `major`、`minor` 和 `patch` 版本的大小总是通过比较数字大小来决定的，例如：`1.0.0` < `2.0.0` < `2.1.0` < `2.1.1`。
  * 当 `major`、`minor` 和 `patch` 版本相同时，带有 `pre-release version` 的版本的优先级始终小于普通版本。例如：`1.0.0-alpha` < `1.0.0`。
  * 比较两个预发布版本的规则与对比 `major`、`minor` 和 `patch` 版本类似，将预发布版本按点分隔符分开，从左到右依次对比这些标识符，且优先级由第一个差异确定，规则如下：
    * 只包含数字的标识符通过比较数字的大小确定优先级，包含字符和中横线的标识符则通过比较字符在 ASCII 码中的顺序来比较优先级。
    * 数字标识符的优先级低于非数字标识符。
    * 通过点分隔符将预发布版本号分割之后，拥有更多的标识符的版本也将拥有更高的优先级。
    * 如果全部都相等，则两个版本优先级相同。

下面是一个完整的例子：

`1.0.0-alpha` < `1.0.0-alpha.1` < `1.0.0-alpha.beta` < `1.0.0-beta` < `1.0.0-beta.2` < `1.0.0-beta.11` < `1.0.0-rc.1` < `1.0.0`

#### 一些建议

以上内容来自：[https://semver.org/#semantic-versioning-200](https://semver.org/#semantic-versioning-200)。如果你正在创建一个包并准备发布它，那么请你遵守这套规则。你可以在你将此链接添加到你的 README 中，这样当别人看到你的包时即可明确的知道你的包时遵守语义版本控制的，这样使用者会对你的包好感倍增，因为使用者会认为遵守语义版本控制的包将更加靠谱，同时也显得更加专业。

#### npm的语义化版本控制

##### 版本范围

`npm` 的语义化版本控制遵守以上介绍的通用规则，如果你是一个包的发布者希望你一定要遵守。如果你是一个包的使用者，那么你还需要注意一些其他内容。比如我们经常会在 `package.json` 中的依赖项中看到诸如下面这样的依赖版本：

`1.0.x`、`~1.0.3`、`^1.0.4`、`2.x`、`*` 等等。

他们代表什么意思呢？

`npm` 中除了明确指定某个包的依赖版本之外，还可以指定版本范围。以 `lodash` 为例：

* `"lodash": "2.4.1"`：只会匹配明确的 `2.4.1` 版本。

但是我们知道 `lodash` 的版本控制是完全依照语义化规范的，所以我们希望如果 `loadsh` 发布了补丁版本则自动安装，此时我们可以使用 `~`：

* `"lodash": "~2.4.1"`：这会匹配补丁版本号大于 `1` 的版本，如 `2.4.2`，但不会匹配诸如 `2.5` 或 `3.0` 等版本

另外既然 `lodash` 的版本控制是完全依照语义化规范的，我们知道次版本号的增加是向后兼容的，所以我们可以考虑如果 `lodash` 发布了次版本则自动安装之，此时我们可以使用 `^`：

* `"lodash": "^2.0.1"`：这会匹配所有大于 `2.0.1` 版本的 `2.x.x` 版本，如 `2.1.0`、`2.4.2` 等等，但不会匹配 `2.0.0`，因为 `2.0.0` 小于 `2.0.1`。

如果你非常激进，只要有新版本就安装之，那么你可以指定 `*` 或 `x`，例如：

* `"lodash": "*"`：匹配所有**非预发布版本**。

感受详细的计算规则大家可以使用：[https://semver.npmjs.com/](https://semver.npmjs.com/)

##### 分发标签(Distribution tags)

分发标签是对 [semantic versioning](http://semver.org/) 的补充，用于管理一个包的不同版本，分发标签具有比语义化版本更高的可读性。

可以使用 `npm dist-tag add <pkg>@<version> [<tag>]` 命令为包的某个版本打上标签。

我们使用 `npm publish` 命令发布一个包的时候，其默认会给当前版本的包打上 `latest` 标签，实际上，当我们使用 `npm install <pkg>` 命令安装一个包时，默认安装的就是 `<pkg>@latest` 版本，除非手动指定版本。

可以使用 `--tag` 指定发布标签，如：`npm publish --tag beta`。

安装的时候也可以指定安装的标签：`npm install somepkg@beta`。

**需要注意的是，由于 `tag` 与 `semver` 具有同样的名称空间，所以在指定标签名字的时候，不要以数字或字母 `v` 开头**。