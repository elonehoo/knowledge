## 一、创建字符串

#### 字面量创建

```js
var str = 'abc'
```
		
#### 包装类型

```js
var str = new String('abc')
```
		
#### ES6模板字符串

```js
var str = `abc`
```
		
#### 使用 String.fromCharCode() / 【ES6】String.fromCodePoint() 将字符编码转成字符串

## 二、字符串基本包装类型的方法

#### 字符方法：

###### str.charAt()
* 描述：访问字符串中特定位置的字符
* 参数：一个数字，表示字符串的位置
* 返回值：返回该位置的字符

###### str.charCodeAt()
* 描述：功能用法与 charAt 相同，唯一不同的是，charCodeAt 返回的是字符编码而不是字符
* 返回值：字符编码

###### 【ES6】str.codePointAt()
* 描述：弥补 `charCodeAt` 不能正确处理需要4个字节表示的字符的缺陷，`codePointAt` 能够正确处理4个字节储存的字符，返回一个字符的码点。可以使用`codePointAt` 来检测一个字符是由两个字节组成，还是由4个字节组成
* 参数：一个数字，字符在字符串中的位置
* 返回值：字符编码

#### 字符串操作方法

###### str.concat()
* 描述：连接多个字符串为一个字符串
* 参数：任意多个参数，要依次连接的字符串
* 返回值：新字符串
* 是否改变原字符串：否

###### str.slice()
###### str.substr()
###### str.substring()
```
描述：上面三个方法都能基于已有字符串创建新字符串，但不会影响原字符串。
参数：第一个参数：指定起始位置
        如果传正数：三个函数行为相同
        如果传负数：substring 会把负数转为0，相当于 substring(0)
    第二个参数：可选
        如果是正数：substr 指定的是返回字符串的数量，substring 和 slice 指定的是字符串的结束位置(返回字符串不包含该位置)
        如果是负数：substr 和 substring 都会把负数变为0
                    substring 会自动调整 0 的位置比如 【substring(3, 0) ==>转化为==> substring(0, 3)】
返回值：新字符串
是否改变原字符串：否
```

###### str.trim()
* 描述：去掉字符串的前后空格
* 参数：无
* 返回值：新字符串
* 是否改变原字符串：否

###### str.toLowerCase()
###### str.toUpperCase()
###### str.toLocaleLowerCase()
###### str.toLocaleUpperCase()
* 描述：字符串转大小写
* 参数：无
* 返回值：转变后的字符串
* 是否改变原字符串：否

###### 【ES6】str.repeat()
* 描述：方法返回一个新字符串，表示将原字符串重复n次
* 参数：

一个大于 `-1` 的数字，表示重复的次数(传递小于 `-1` 的数字会报错，传递小数会取整，之所以可以传递 -1 ~ 0 之间的数字是因为，-1 ~ 0之间的数字取整后都为0，并不会报错)

* 返回值：新字符串
* 是否改变原字符串：否

###### 【ES7】padStart()
###### 【ES7】padEnd()
```
描述：对字符串进行补全，padStart 前补全，padEnd 后补全
参数：第一个参数：字符串的最小长度
        第二个参数：可选，用来填充的字符串，默认用空格填充
是否改变原字符串：否
```

#### 字符串位置方法

###### str.indexOf()
###### str.lastIndexOf()
```
描述：从一个字符串中搜索子字符串，并返回子字符串第一次出现的位置（不同的是：indexOf 从前往后找， lastIndexOf 从后往前找）
参数：第一个参数：要查找的子字符串
        第二个参数：查找的起始位置
返回值：子字符串第一次出现的位置，未找到返回-1
是否改变原字符串：否
```

###### 【ES6】str.includes()
###### 【ES6】str.startsWith()
###### 【ES6】str.endsWith()
```
描述：上面三个函数都是查找字符串中是否包含子字符串
    str.includes() ：字符串是否包含子字符串
    str.startsWith() ：字符串是否以子字符串开头
    str.endsWith() ：字符串是否以子字符串结尾
参数：第一个参数：子字符串
        第二个参数：查找的起始位置【注意：给endsWith指定第二个参数n是，它指的是前n个字符】
返回值：满足条件返回 true，否则返回 false
```


#### 模式匹配方法

###### str.match()
* 描述：通过模式匹配字符串
* 参数：字符串 / 正则表达式 / RegExp 对象
* 返回值：如果匹配成功则返回数组，数组的第一项是与整个模式匹配的项，后面的每一项保存着与正则表达式中的捕获组匹配的字符串。如果匹配失败返回 `null`

###### str.search()
* 描述：和 indexOf 功能相似，唯一不同的是：该方法支持正则
* 参数：字符串 / 正则表达式 / RegExp 对象
* 返回值：返回第一个匹配项的索引，没有找到返回 -1

###### str.replace()
* 描述：通过模式替换匹配的字符串
* 参数：
```
    第一个参数：字符串 / 正则表达式
    第二个参数：字符串 / 函数
        如果第二个参数是字符串：可以使用特殊的字符序列：
            $$ =====> $
            $& =====> 匹配整个模式的字符串，与RegExp.lastMatch的值相同
            $' =====> 匹配的子字符串之后的子字符串，与RegExp.rightContext的值相同
            $` =====> 匹配的子字符串之前的子字符串，与RegExp.leftContext的值相同
            $n =====> 匹配第n(0 ~ 9)个捕获组的子字符串，如果正则表达式中没有捕获组，则使用空字符串
            $nn =====> 匹配第nn(01 ~ 99)个捕获组的子字符串，如果正则表达式中没有捕获组，则使用空字符串
        如果第二个参数是函数：(该函数接收的参数与正则表达式有关)
            1、正则表达式只有一个匹配项，即无捕获组
                该函数接收三个参数：第一个：模式的匹配项
                                    第二个：模式匹配项在字符串中的位置
                                    第三个：原始字符串
            2、正则表达式中定义了多个捕获组
                该函数接收参数如下：第一个：模式的匹配项
                                    第二个 ~ 第n个：第二个捕获组的匹配项 ~ 第n个捕获组的匹配项
                                    最后两个参数分别是：模式匹配项在字符串中的位置 和 原始字符串
```
* 返回值：新字符串
* 是否改变原字符串：否

###### str.split()
* 描述：基于指定的字符或模式，将字符串分割成数组
* 参数：
    * 第一个参数：字符串 / 正则表达式
    * 第二个参数：指定数组的长度

#### 字符串比较方法

###### str.localeCompare(str2)
* 描述：对两个字符串进行比较
* 参数：字符串
* 返回值：
    ```
    如果 str > str2 ，返回 1
    如果 str = str2 ，返回 0
    如果 str < str2 ，返回 -1
    ```

###### 【ES6】str1.normalize()
* 描述：ES6提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。
* 参数：
```
    'NFC' : 
    默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。

    'NFD' :
    表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。
    'NFKC' :
    表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）
    'NFKD' :
    表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。
```
#### String构造函数的静态方法

###### String.fromCharCode()
* 描述：接受一至多个字符编码，然后将他们转换成一个字符串
* 参数：1 ~ n 个字符编码
* 返回值：字符串

###### 【ES6】String.fromCodePoint()
* 描述：接受一至多个字符编码，然后将他们转换成字符串，该方法弥补 `String.fromCharCode()` 方法不能识别字符编码大于0xFFFF的缺陷

#### 字符串的其他扩展

ES6为字符串添加了遍历器接口(Iterator)，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的 `for` 循环无法识别这样的码点。